import { Schema } from '@aws-cdk/aws-glue-alpha';
import { App, Stack } from 'aws-cdk-lib';
import { Role, ServicePrincipal } from 'aws-cdk-lib/aws-iam';
import { Transform } from '../src';
import { SomeNode } from './node.test';

describe('DropFields', () => {
  test('Must be able to specify name', () => {
    const defaultName = Transform.dropFields('node1', {
      fields: ['will_drop'],
    });
    const specifyName = Transform.dropFields('node2', {
      name: 'Specify Name',
      fields: ['will_drop'],
    });
    expect(defaultName.name).toBe('Drop Fields');
    expect(specifyName.name).toBe('Specify Name');
  });

  test('If not provide granter and grant then not throw error', () => {
    const app = new App();
    const stack = new Stack(app, 'MyStack');
    const dropFields = Transform.dropFields('node1', {
      fields: ['will_drop'],
    });
    dropFields.grant(
      new Role(stack, 'Role', {
        assumedBy: new ServicePrincipal('glue.amazonaws.com'),
      })
    );
  });

  test('No inputs and build then python throw error', () => {
    const dropFields = Transform.dropFields('node1', {
      fields: ['will_drop'],
    });
    expect(() => dropFields.python()).toThrow(
      'You need to choose exactly 1 parent(s) for DropFields Transform. Now 0 parent(s).'
    );
  });

  test('2 inputs and build then python throw error', () => {
    const dropFields = Transform.dropFields('node1', {
      fields: ['will_drop1', 'will_drop2'],
    });
    new SomeNode('Input1').to(dropFields);
    new SomeNode('Input2').to(dropFields);
    expect(() => dropFields.python()).toThrow(
      'You need to choose exactly 1 parent(s) for DropFields Transform. Now 2 parent(s).'
    );
  });

  test('Python should build code', () => {
    const dropFields = Transform.dropFields('node1', {
      fields: ['will_drop1', 'will_drop2'],
    });
    const prevNode = new SomeNode('prev_node');
    prevNode.to(dropFields);
    const code = dropFields.python();
    expect(code.imports).toStrictEqual([]);
    expect(code.body).toStrictEqual([
      `# Script generated by CDK for node Drop Fields
DropFields_node1 = DropFields.apply(
    frame=SomeNode_prev_node,
    paths=[\"will_drop1\",\"will_drop2\"],
    transformation_ctx=\"DropFields_node1\",
)`,
    ]);
  });

  test('Scala not implement', () => {
    const dropFields = Transform.dropFields('DropFields', {
      fields: ['will_drop1', 'will_drop2'],
    });
    const prevNode = new SomeNode('prev_node');
    prevNode.to(dropFields);
    expect(() => dropFields.scala()).toThrow();
  });
});

describe('SelectFields', () => {
  test('Must be able to specify name', () => {
    const defaultName = Transform.selectFields('node1', {
      fields: ['fields'],
    });
    const specifyName = Transform.selectFields('node2', {
      name: 'Specify Name',
      fields: ['fields'],
    });
    expect(defaultName.name).toBe('Select Fields');
    expect(specifyName.name).toBe('Specify Name');
  });

  test('If not provide granter and grant then not throw error', () => {
    const app = new App();
    const stack = new Stack(app, 'MyStack');
    const selectFields = Transform.selectFields('node1', {
      fields: ['fields'],
    });
    selectFields.grant(
      new Role(stack, 'Role', {
        assumedBy: new ServicePrincipal('glue.amazonaws.com'),
      })
    );
  });

  test('No inputs and build then python throw error', () => {
    const selectFields = Transform.selectFields('node1', {
      fields: ['fields'],
    });
    expect(() => selectFields.python()).toThrow(
      'You need to choose exactly 1 parent(s) for SelectFields Transform.'
    );
  });

  test('2 inputs and build then python throw error', () => {
    const selectFields = Transform.selectFields('node1', {
      fields: ['fields1', 'fields2'],
    });
    new SomeNode('Input1').to(selectFields);
    new SomeNode('Input2').to(selectFields);
    expect(() => selectFields.python()).toThrow(
      'You need to choose exactly 1 parent(s) for SelectFields Transform.'
    );
  });

  test('Python should build code', () => {
    const selectFields = Transform.selectFields('node1', {
      fields: ['fields1', 'fields2'],
    });
    const prevNode = new SomeNode('prev_node');
    prevNode.to(selectFields);
    const code = selectFields.python();
    expect(code.imports).toStrictEqual([]);
    expect(code.body).toStrictEqual([
      `# Script generated by CDK for node Select Fields
SelectFields_node1 = SelectFields.apply(
    frame=SomeNode_prev_node,
    paths=[\"fields1\",\"fields2\"],
    transformation_ctx=\"SelectFields_node1\",
)`,
    ]);
  });

  test('Scala not implement', () => {
    const selectFields = Transform.selectFields('SelectFields', {
      fields: ['fields1', 'fields2'],
    });
    const prevNode = new SomeNode('prev_node');
    prevNode.to(selectFields);
    expect(() => selectFields.scala()).toThrow();
  });
});

describe('ApplyMapping', () => {
  test('Must be able to specify name', () => {
    const defaultName = Transform.applyMapping('node1', {
      mappings: [],
    });
    const specifyName = Transform.applyMapping('node2', {
      name: 'Specify Name',
      mappings: [],
    });
    expect(defaultName.name).toBe('Apply Mapping');
    expect(specifyName.name).toBe('Specify Name');
  });

  test('If not provide granter and grant then not throw error', () => {
    const app = new App();
    const stack = new Stack(app, 'MyStack');
    const applyMapping = Transform.applyMapping('node1', {
      mappings: [],
    });
    applyMapping.grant(
      new Role(stack, 'Role', {
        assumedBy: new ServicePrincipal('glue.amazonaws.com'),
      })
    );
  });

  test('No inputs and build then python throw error', () => {
    const applyMapping = Transform.applyMapping('node1', {
      mappings: [],
    });
    expect(() => applyMapping.python()).toThrow(
      'You need to choose exactly 1 parent(s) for ApplyMapping Transform.'
    );
  });

  test('2 inputs and build then python throw error', () => {
    const applyMapping = Transform.applyMapping('node1', {
      mappings: [],
    });
    new SomeNode('Input1').to(applyMapping);
    new SomeNode('Input2').to(applyMapping);
    expect(() => applyMapping.python()).toThrow(
      'You need to choose exactly 1 parent(s) for ApplyMapping Transform.'
    );
  });

  test('Python should build code', () => {
    const applyMapping = Transform.applyMapping('node1', {
      mappings: [
        {
          source: { name: 'type_change', type: Schema.STRING },
          target: { name: 'type_change', type: Schema.INTEGER },
        },
        {
          source: { name: 'name_change', type: Schema.STRING },
          target: { name: 'renamed', type: Schema.STRING },
        },
      ],
    });
    const prevNode = new SomeNode('prev_node');
    prevNode.to(applyMapping);
    const code = applyMapping.python();
    expect(code.imports).toStrictEqual([]);
    expect(code.body).toStrictEqual([
      `# Script generated by CDK for node Apply Mapping
ApplyMapping_node1 = ApplyMapping.apply(
    frame=SomeNode_prev_node,
    mappings=[
        ("type_change", "string", "type_change", "int"),
        ("name_change", "string", "renamed", "string"),
    ],
    transformation_ctx=\"ApplyMapping_node1\",
)`,
    ]);
  });

  test('Scala not implement', () => {
    const applyMapping = Transform.applyMapping('ApplyMapping', {
      mappings: [],
    });
    const prevNode = new SomeNode('prev_node');
    prevNode.to(applyMapping);
    expect(() => applyMapping.scala()).toThrow();
  });
});
