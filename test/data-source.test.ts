import { Database, DataFormat, Schema, Table } from '@aws-cdk/aws-glue-alpha';
import { App, Stack } from 'aws-cdk-lib';
import { Template } from 'aws-cdk-lib/assertions';
import { Role, ServicePrincipal } from 'aws-cdk-lib/aws-iam';
import { DataSource } from '../src';
import { SomeNode } from './node.test';

describe('CatalogSource', () => {
  const createTable = () => {
    const app = new App();
    const stack = new Stack(app, 'MyStack');
    const database = new Database(stack, 'Database', {
      databaseName: 'my_database',
    });
    const table = new Table(stack, 'Table', {
      database,
      tableName: 'my_table',
      dataFormat: DataFormat.PARQUET,
      columns: [{ name: 'mycolumn', type: Schema.STRING }],
    });
    return {
      app,
      stack,
      database,
      table,
    };
  };

  test('Must be able to specify name', () => {
    const { database, table } = createTable();
    const defaultName = DataSource.catalog('node1', {
      database,
      table,
    });
    const specifyName = DataSource.catalog('node2', {
      name: 'Specify Name',
      database,
      table,
    });
    expect(defaultName.name).toBe('AWS Glue Data Catalog');
    expect(specifyName.name).toBe('Specify Name');
  });

  test('Throwing errors when setting inputs', () => {
    const { database, table } = createTable();
    const catalog = DataSource.catalog('node1', {
      database,
      table,
    });
    new SomeNode('Input1').to(catalog);
    expect(() => catalog.python()).toThrow(
      'The catalog source cannot set inputs.'
    );
  });

  test('If not provide granter and grant then not throw error', () => {
    const { stack, database, table } = createTable();
    const catalog = DataSource.catalog('node1', {
      database,
      table,
    });
    const role = new Role(stack, 'Grantee', {
      assumedBy: new ServicePrincipal('glue.amazonaws.com'),
    });
    catalog.grant(role);
  });

  test('Python should build code', () => {
    const { database, table } = createTable();
    const catalog = DataSource.catalog('node1', {
      database,
      table,
    });
    const next = new SomeNode('next_node');
    catalog.to(next);
    const code = catalog.python();
    expect(code.imports).toBeUndefined();
    expect(code.head).toBeUndefined();
    expect(code.body).toStrictEqual([
      `# Script generated by CDK for node AWS Glue Data Catalog
AWSGlueDataCatalog_node1 = glueContext.create_dynamic_frame.from_catalog(
    database="${database.databaseName}",
    table_name="${table.tableName}",
    transformation_ctx="AWSGlueDataCatalog_node1",
)`,
    ]);
    expect(code.tail).toBeUndefined();
  });

  test('Scala not implement', () => {
    const { database, table } = createTable();
    const catalog = DataSource.catalog('node1', {
      database,
      table,
    });
    const next = new SomeNode('next_node');
    next.to(catalog);
    expect(() => catalog.scala()).toThrow();
  });
});

describe('S3CatalogSource', () => {
  const createTable = () => {
    const app = new App();
    const stack = new Stack(app, 'MyStack');
    const database = new Database(stack, 'Database', {
      databaseName: 'my_database',
    });
    const table = new Table(stack, 'Table', {
      database,
      tableName: 'my_table',
      dataFormat: DataFormat.PARQUET,
      columns: [{ name: 'mycolumn', type: Schema.STRING }],
    });
    return {
      app,
      stack,
      database,
      table,
    };
  };

  test('Must be able to specify name', () => {
    const { database, table } = createTable();
    const defaultName = DataSource.s3Catalog('node1', {
      database,
      table,
      bucket: table.bucket,
    });
    const specifyName = DataSource.s3Catalog('node2', {
      name: 'Specify Name',
      database,
      table,
      bucket: table.bucket,
    });
    expect(defaultName.name).toBe('Amazon S3');
    expect(specifyName.name).toBe('Specify Name');
  });

  test('Throwing errors when setting inputs', () => {
    const { database, table } = createTable();
    const catalog = DataSource.s3Catalog('node1', {
      database,
      table,
      bucket: table.bucket,
    });
    new SomeNode('Input1').to(catalog);
    expect(() => catalog.python()).toThrow(
      'The catalog source cannot set inputs.'
    );
  });

  test('Grant the bucket', () => {
    const { stack, database, table } = createTable();
    const catalog = DataSource.s3Catalog('node1', {
      database,
      table,
      bucket: table.bucket,
    });
    const role = new Role(stack, 'Grantee', {
      assumedBy: new ServicePrincipal('glue.amazonaws.com'),
    });
    catalog.grant(role);
    const template = Template.fromStack(stack);
    template.hasResourceProperties('AWS::IAM::Policy', {
      PolicyDocument: {
        Statement: [
          {
            Action: ['s3:GetObject*', 's3:GetBucket*', 's3:List*'],
            Effect: 'Allow',
            Resource: stack.resolve([
              table.bucket.bucketArn,
              `${table.bucket.bucketArn}/*`,
            ]),
          },
        ],
      },
    });
  });

  test('Python should build code', () => {
    const { database, table } = createTable();
    const catalog = DataSource.s3Catalog('node1', {
      database,
      table,
      bucket: table.bucket,
    });
    const next = new SomeNode('next_node');
    catalog.to(next);
    const code = catalog.python();
    expect(code.imports).toBeUndefined();
    expect(code.head).toBeUndefined();
    expect(code.body).toStrictEqual([
      `# Script generated by CDK for node Amazon S3
AmazonS3_node1 = glueContext.create_dynamic_frame.from_catalog(
    database="${database.databaseName}",
    table_name="${table.tableName}",
    transformation_ctx="AmazonS3_node1",
)`,
    ]);
    expect(code.tail).toBeUndefined();
  });

  test('Scala not implement', () => {
    const { database, table } = createTable();
    const catalog = DataSource.s3Catalog('node1', {
      database,
      table,
      bucket: table.bucket,
    });
    const next = new SomeNode('next_node');
    next.to(catalog);
    expect(() => catalog.scala()).toThrow();
  });
});
