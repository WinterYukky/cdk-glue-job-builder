import { Database, DataFormat, Schema, Table } from '@aws-cdk/aws-glue-alpha';
import { App, Stack } from 'aws-cdk-lib';
import { Template } from 'aws-cdk-lib/assertions';
import { Role, ServicePrincipal } from 'aws-cdk-lib/aws-iam';
import { DataTarget } from '../src';
import { SomeNode } from './node.test';

const createTable = () => {
  const app = new App();
  const stack = new Stack(app, 'MyStack');
  const database = new Database(stack, 'Database', {
    databaseName: 'my_database',
  });
  const table = new Table(stack, 'Table', {
    database,
    tableName: 'my_table',
    dataFormat: DataFormat.PARQUET,
    columns: [{ name: 'mycolumn', type: Schema.STRING }],
  });
  return {
    app,
    stack,
    database,
    table,
  };
};

describe('CatalogTarget', () => {
  test('Must be able to specify name', () => {
    const { database, table } = createTable();
    const defaultName = DataTarget.catalog('node1', {
      database,
      table,
    });
    const specifyName = DataTarget.catalog('node2', {
      name: 'Specify Name',
      database,
      table,
    });
    expect(defaultName.name).toBe('AWS Glue Data Catalog');
    expect(specifyName.name).toBe('Specify Name');
  });

  test('If not provide granter and grant then not throw error', () => {
    const { stack, database, table } = createTable();
    const catalog = DataTarget.catalog('node1', {
      database,
      table,
    });
    const role = new Role(stack, 'Grantee', {
      assumedBy: new ServicePrincipal('glue.amazonaws.com'),
    });
    catalog.grant(role);
  });

  test('No inputs and build then python throw error', () => {
    const { database, table } = createTable();
    const catalog = DataTarget.catalog('node1', {
      database,
      table,
    });
    expect(() => catalog.python()).toThrow(
      'The catalog target node used to require one input node, but now there are 0 input nodes available.'
    );
  });

  test('2 inputs and build then python throw error', () => {
    const { database, table } = createTable();
    const catalog = DataTarget.catalog('node1', {
      database,
      table,
    });
    new SomeNode('Input1').to(catalog);
    new SomeNode('Input2').to(catalog);
    expect(() => catalog.python()).toThrow(
      'The catalog target node used to require one input node, but now there are 2 input nodes available.'
    );
  });

  test('Python should build code', () => {
    const { database, table } = createTable();
    const catalog = DataTarget.catalog('node1', {
      database,
      table,
    });
    const prevNode = new SomeNode('prev_node');
    prevNode.to(catalog);
    const code = catalog.python();
    expect(code.imports).toBeUndefined();
    expect(code.head).toBeUndefined();
    expect(code.body).toStrictEqual([
      `# Script generated by CDK for node AWS Glue Data Catalog
AWSGlueDataCatalog_node1 = glueContext.write_dynamic_frame.from_catalog(
    frame=SomeNode_prev_node,
    database="${database.databaseName}",
    table_name="${table.tableName}",
    transformation_ctx="AWSGlueDataCatalog_node1",
)`,
    ]);
    expect(code.tail).toBeUndefined();
  });

  test('Scala not implement', () => {
    const { database, table } = createTable();
    const catalog = DataTarget.catalog('node1', {
      database,
      table,
    });
    const prevNode = new SomeNode('prev_node');
    prevNode.to(catalog);
    expect(() => catalog.scala()).toThrow();
  });
});

describe('S3CatalogTarget', () => {
  test('Must be able to specify name', () => {
    const { database, table } = createTable();
    const defaultName = DataTarget.s3Catalog('node1', {
      database,
      table,
      bucket: table.bucket,
    });
    const specifyName = DataTarget.s3Catalog('node2', {
      name: 'Specify Name',
      database,
      table,
      bucket: table.bucket,
    });
    expect(defaultName.name).toBe('Amazon S3');
    expect(specifyName.name).toBe('Specify Name');
  });

  test('Grant the bucket', () => {
    const { stack, database, table } = createTable();
    const catalog = DataTarget.s3Catalog('node1', {
      database,
      table,
      bucket: table.bucket,
    });
    const role = new Role(stack, 'Grantee', {
      assumedBy: new ServicePrincipal('glue.amazonaws.com'),
    });
    catalog.grant(role);
    const template = Template.fromStack(stack);
    template.hasResourceProperties('AWS::IAM::Policy', {
      PolicyDocument: {
        Statement: [
          {
            Action: [
              's3:DeleteObject*',
              's3:PutObject',
              's3:PutObjectLegalHold',
              's3:PutObjectRetention',
              's3:PutObjectTagging',
              's3:PutObjectVersionTagging',
              's3:Abort*',
            ],
            Effect: 'Allow',
            Resource: stack.resolve([
              table.bucket.bucketArn,
              `${table.bucket.bucketArn}/*`,
            ]),
          },
        ],
      },
    });
  });

  test('Python should build code', () => {
    const { database, table } = createTable();
    const catalog = DataTarget.s3Catalog('node1', {
      database,
      table,
      bucket: table.bucket,
    });
    const prev = new SomeNode('prev_node');
    const next = new SomeNode('next_node');
    prev.to(catalog).to(next);
    const code = catalog.python();
    expect(code.imports).toBeUndefined();
    expect(code.head).toBeUndefined();
    expect(code.body).toStrictEqual([
      `# Script generated by CDK for node Amazon S3
AmazonS3_node1 = glueContext.write_dynamic_frame.from_catalog(
    frame=SomeNode_prev_node,
    database="${database.databaseName}",
    table_name="${table.tableName}",
    transformation_ctx="AmazonS3_node1",
)`,
    ]);
    expect(code.tail).toBeUndefined();
  });

  test('Scala not implement', () => {
    const { database, table } = createTable();
    const catalog = DataTarget.s3Catalog('node1', {
      database,
      table,
      bucket: table.bucket,
    });
    const next = new SomeNode('next_node');
    next.to(catalog);
    expect(() => catalog.scala()).toThrow();
  });
});
